// Copyright 2017-2021 @polkadot/util-crypto authors & contributors
// SPDX-License-Identifier: Apache-2.0
// Original implementation: https://github.com/paritytech/polka-ui/blob/4858c094684769080f5811f32b081dd7780b0880/src/polkadot.js#L6
import { assert, isHex, isU8a, u8aToU8a } from '@polkadot/util';
import { base58Decode } from "../base58/decode.mjs";
import { checkAddressChecksum } from "./checksum.mjs";
import { defaults } from "./defaults.mjs"; // eslint-disable-next-line @typescript-eslint/no-unused-vars

export function decodeAddress(encoded, ignoreChecksum, ss58Format = -1) {
  if (isU8a(encoded) || isHex(encoded)) {
    return u8aToU8a(encoded);
  }

  const wrapError = message => `Decoding ${encoded}: ${message}`;

  let decoded;

  try {
    decoded = base58Decode(encoded);
  } catch (error) {
    throw new Error(wrapError(error.message));
  } // assert(defaults.allowedPrefix.includes(decoded[0] as Prefix), error('Invalid decoded address prefix'));


  assert(defaults.allowedEncodedLengths.includes(decoded.length), wrapError('Invalid decoded address length')); // TODO Unless it is an "use everywhere" prefix, throw an error
  // if (ss58Format !== -1 && (decoded[0] !== ss58Format)) {
  //   console.log(`WARN: Expected ${ss58Format}, found ${decoded[0]}`);
  // }

  const [isValid, endPos] = checkAddressChecksum(decoded);
  assert(ignoreChecksum || isValid, wrapError('Invalid decoded address checksum'));
  return decoded.slice(1, endPos);
}